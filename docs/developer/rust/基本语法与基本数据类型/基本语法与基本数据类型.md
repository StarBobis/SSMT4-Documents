# 变量与可变性

Rust 中, **变量 (Variable)** 默认不可变:

```rust
let a = 0;  // 定义 a 并初始化为 0
// a = 1;   // 尝试为不可变变量 a 赋值 1, 报错
```

如果需要可变性, 则必须手动添加**可变 (<span style="color:cyan">Mut</span>able)** 关键字显式标记:

```rust
let a = 0;
let mut b = 1; // 定义可变的 b 并初始化为 1;
// a = 2;   // <------- 不允许
b = 3;      // <------- 允许
```

不过注意, 不可变并非意味着不可初始化:

```rust
let a;  // 定义 a
a = 1;  // 初始化 a 为 1, 因为这是 a 第一次被赋值
// a = 2;// 再次尝试赋值, 报错
```

如此分离**定义引入**与**初始化**, 并无问题, 但若需二次赋值, 则必须显式标记其可变.

# 类型推断

Rust 是静态强类型语言, 这意味着所有变量的类型都固定且不可变. 但上述代码中, 我们并没有手动写出变量的类型, 那么 Rust 该如何确定变量类型呢?

实际上, Rust 编译器装配了强大的类型推断能力, 只要编译器能够推断出变量的类型, 代码就允许编译通过. 上文代码等价于下述:

```Rust
//----------------
let a: i32 = 0;     // 根据初始化值直接推导
//----------------
let a: i32 = 0;
let mut b: i32 = 0;
b = 3;
//----------------
let a: i32;
a = 1;              // 根据后文的初始化推导到前文
```

但有些时候, 编译器无法成功推导类型, 此时必须手动标注类型. 一般只会出现在部分实现了复杂泛型的堆数据中. 遇到时就能明白为何不能自动推导.

## 默认类型

一些供于变量初始化的值有众多不同可行的类型, 此时如果不手动指定, 类型推导会使用其中的默认类型, 我们将在本文下面说明默认类型有哪些.

# 常量

可以用关键字 `const` 标记**常量 (Constant)**:

```Rust
const PI: f64 = 3.1415926;
```

常量永远不具备可变性, 定义时也必须手动指定其数据类型. 此外, 常量允许定义在任何作用域中, 包括函数体外部:

```rust
const PI: f64 = 3.1415926;
fn main() {
    println!("{}", PI);
    const SHIMOKITAZAWA: i32 = 114514;
    println!("{}", SHIMOKITAZAWA);
}
```

此外, 常量仅允许常量表达式赋值, 也必须定义时就赋值:

```rust
const CONST_A: i32 = 114;           // 直接赋值, 无错
const CONST_B: i32 = 114 + 514;     // 常量表达式赋值, 无错, 将在编译期直接得到结果
//-----------------------------------------
// let tmp = 1919;                  // 先定义一个变量,
// const CONST_C: i32 = tmp + 810;  // 然后定义常量为一个变量参与的表达式, 不允许
//------------------------------------------
// const CONST_D: i32;              // 定义常量,
// CONST_D = 12345;                 // 然后赋值, 不可行, 报错.
```

事实上, Rust 代码检查器设计上就不支持常量类型推导, 因为常量总会内联到使用处直接参与逻辑.
:::tip 常量之于不可变变量
有人问不可变变量与常量的区别在何处. 不可变变量允许一次初始化赋值, 本次赋值允许 Rust 所有可行的表达式, 而常量仅仅作为某些固定值的助记符而存在, 不具有任何高级功能.

另一个角度, 为什么变量默认不可变? 答案是 Rust 由工程实践得出结论, 在现行语言中, 变量大多数情况下仅需要一次赋值, 而后无需可变, 但绝大多数变量仍可变, 这带来了不可预期的负面影响.
:::

# 变量遮蔽

Rust 中多次定义相同名称的变量完全可行:

```Rust
fn main() {             //<----进入主函数域
    let a = 1;              // 定义 a1: i32 为 1
    let a = 2;              // 遮蔽 a1, 定义 a2: i32 为 2
    let a = "3";            // 遮蔽 a2, 定义 a3: &str 为字符串字面量 "3"
    let a = String::from(a);// 遮蔽 a3, 定义 a4 为 a3 被 String 库的 from 方法转换得到的字符串 "3"
    println!("{a}");
    {                   //<----进入域
        println!("{a}");
        let a = 5.555;      // 遮蔽 a4, 定义 a5: f64 为 5.555
        println!("{a}");
        let a = "6";        // 遮蔽 a5, 定义 a6: &str 为字面量 "6"
    }                   //<----退出域, a6 被释放, 导致 a5 重新可见
                        //     a5 同样因退出域被释放, 导致 a4 重新可见
    println!("{a}");
}                       //<----退出域, a4 被释放.
                        //     a3, a2, a1 依次取消遮蔽, 但同时因为离开作用域, 被释放
```

编译运行上述代码, 理应得到结果:

```shell
"3"
"3"
5.555
"3"
```

根据我们将会学到的**生命周期**系统, 可以这么理解:

```rust
fn main() {            //-----------------------------------//
    let a = 1;                  // a1                       //
    let a = 2;                  // |  a2                    //
    let a = "3";                // |  |  a3                 //
    let a = String::from(a);    // |  |  |  a4              //
    println!("{a}");            // |  |  |  |<--------------//----- println!("{a}");
    {                       //-----|--|--|--|---------//    //
        println!("{a}");    //  // |  |  |  |<--------//----//----- println!("{a}");
        let a = 5.555;      //  // |  |  |  |  a5     //    //
        println!("{a}");    //  // |  |  |  |  |<-----//----//----- println!("{a}");
        let a = "6";        //  // |  |  |  |  |   a6 //    //
    }                       //-----|--|--|--|--x-- x--//    //
    println!("{a}");            // |  |  |  |<--------------//----- println!("{a}");
}                      //----------x--x--x--x---------------//
```

后定义的变量将覆盖在先定义的变量上, 当方法或函数希望调用变量时, 仅会访问到最上层的那个.

# 数据类型

基本的数据类型分两类, 标量类型与复合类型.

## 标量类型

### 整形 (Integer)

整形按占据比特数多少与是否有符号有如下类型:

| 长度 | 有符号 | 无符号 |
| ---- | ------ | ------ |
| 8    | i8     | u8     |
| 16   | i16    | u16    |
| 32   | i32    | u32    |
| 64   | i64    | u64    |
| 128  | i128   | u128   |
| arch | isize  | usize  |

其中 isize 和 usize 占据比特数与操作系统位数 (32/64) 一致.

$n$ 字节类型能够表示的数, 总计必然为 $2^n$ 个, 对 $\mathrm{u}n$ 而言, 范围为 $ 0\sim 2^n-1 $, 而对 $\mathrm{i}n$ 而言, 范围为 $-2^{n-1}\sim2^{n-1}-1$.

除了表示范围及有无符号外, 整形的字面形式也有多种, 不止于我们常见的十进制:

| 字面值      | 例子        | 写法                           |
| ----------- | ----------- | ------------------------------ |
| Decimal     | 114_514     | 直接写                         |
| Hexadecimal | 0x1234abcd  | `0x` 开头                      |
| Octal       | 0o123456    | `0o` 开头                      |
| Binary      | 0b1101_1011 | `0b` 开头                      |
| Byte (u8)   | b'A'        | 以 `b'  '` 包裹的单 ASCLL 字符 |

::: tip 下划线
:::
::: tip ascll
:::
float: f64
f32
f64
(f128)
都有符号

bool
两个值: true/false
1字节8bit

char
`let some_char: char = 'A';`
可以表示一个 Unicode 标量值
4 byte

复合类型

Tuple 元组
不同元素

`let a = ('A',1,0.1);`
`let b: (i32, f64, u8) = (100,1.0,2);`
`let c = b.0;`
定长, 类型不必一致

Array 组

```rust
let arr1 = [1,2,3];
let arr2 = [i32; 3] = [1,2,3];
let arr3 = [3;5];
let a = arr1[0];
```

定长, 类型唯一

模式匹配:

```rust
let arr = ("mp4","m4v","mov");
let (mp4, m4v, mov) = arr;
//---------变量遮蔽------------
let arr = ["mp4","m4v","mov"];
let [mp4, m4v, mov] = arr;
// 也可以只取用所需
let [mp4,..] = arr;
let [_,m4v,_] = arr;
```
