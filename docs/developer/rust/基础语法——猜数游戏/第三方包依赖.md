## 本小节目标
引入第三方包, 生成 0~100 间的随机数.

### 导入第三方包
请复制代码到你的编辑器:
```rust
use std::io;
use rand::random_range;

fn main() {
    println!("请猜测一个数");

    let secret_num = random_range(1..100);

    let mut guess = String::new();
    io::
        stdin()
        .read_line(&mut guess)
        .expect("读取有误时的报错");
    println!("你猜的是: {}", guess);
}
```
预期中, 编辑器将会在第二行处报错:
```shell
error[E0432]: unresolved import `rand`
 --> src\main.rs:2:5
  |
2 | use rand::random_range;
  |     ^^^^ use of unresolved module or unlinked crate `rand`
  |
  = help: if you wanted to use a crate named `rand`, use `cargo add rand` to add it to your `Cargo.toml`
```
其实原文逐字翻译就能看明白:
```shell
error[E0432]: 未解决的导入 `rand`
 --> 位于 src\main.rs 的第 2 行第 5 个字符
  |
3 | use rand::random_range;
  |     ^^^^ 使用了未解决的导入或未链接的包 `rand`
  |
  = 帮助: 若期望使用名为 `rand` 的包, 使用 `cargo add rand` 以添加其至你的 `Cargo.toml` 文件
```
看来报错的原因即, 我们必须手动引入 `rand` 这个第三方包. 如何引入呢? 通常推荐直接在当前工作空间运行
```shell
cargo add rand
```
然后 Cargo 会自行安装最新版本的 `rand` 包, 并且将其版本锁定于 `Cargo.lock` 文件中. 除此之外, 也可以手动在 `Cargo.toml` 的 `[dependencies]` 节下添加一行
```toml
rand = "0.10.0"
```
指定 `rand` 的版本, 或
```toml
rand = "^0.10.0"
```
以指定为所有与该版本 API 互通的版本. 保存配置文件后, Cargo 会自行重新检查代码, 如果没有问题, 代码理应不再报错.
:::warning `Cargo.lock`
开发者通常无需修改也不应修改 `Cargo.lock` 文件.
:::
### 代码说明
代码本身的含义应该很好理解:
```rust
let secret_num = random_range(1..=100);
```
意为定义变量 `secret_num` 为集合 $[1,100]\cap\mathbb{I}_{32}$ 中的一个随机数. 通过代码自动提示可以获知 `secret_num` 为 **i32** 变量, 也就是 32 位整形, 这由我们传入的迭代器 `1..=100` 决定, 实际上 `random_range()` 这个函数也通过泛型定义支持各种类型的传入参数, 并以此决定传出的类型. 比如我们可以将代码修改为
```rust
let secret_num = random_range(1.0..=100.0);
```
其中 `1.0` 这样的形式向编译器提醒为浮点类型, 默认为 64 位浮点, 即 **f64** 类型, 此时意为取随机数于集合 $[1,100]\cap\mathbb{F}_{64}$.
::: tip
代码中的迭代器也可以写作
```rust
let secret_num = random_range(1..101);
```
这与 `1..=100` 效果上一致, 意即 $ [1,101)\cap\mathbb{I}_{64} $.
:::